demo使用的Storm版本是Apache-storm-0.93版本

demo是JavaAPI操作storm的小例子,实现的是单词个数统计的功能

demo1是保证数据至多执行一次的情况,存在丢失的可能性,

demo2是保证了数据至少执行一次,存在重复处理的可能性
重写ack(),fail()的作用,spout,bolt向collector对象进行锚定
demo2增加了Java代码对Storm的Worker,Executor及Task数量的设置及注释

demo3实现了storm有且仅有执行一次
通过storm 组织批实现

关于重复数据的处理:
如果程序维护一个map/set,每次数据处理前,都到map/set中查看是否已经被处理过,则程序在运行一段时间后,该map/set越来越大,占据更大的内存空间,同时查询的时间也会变长,影响程序运行
如果让所有的tuple的编号严格按照顺序递增,且要求整个topology严格按照顺序处理这些tuple,那就只需要记录最后一次处理的tuple元祖的编号,那么为了保证tuple的处理顺序,则要所有的tuple处理时其他tuple需要等待,按顺序进行,这样同样效率非常低
如果每次发送一个批的数据,批与批之间穿行,批内的tuple并发,效率稍微有所提升

但是根据业务特点,以本单词计数为例,split过程和打印过程不影响计数结果, 唯一核心的就是计数的bolt, 这个时候只要保证此处的顺序,那整个业务影响不大,而且batch和batch之间在某些节点上可以并发处理,效率大大提高

这就有点像JDBC中,PrepareStatement的批处理了